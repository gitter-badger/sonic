import Id from './id';
export interface IList<V> {
    has: (id: Id) => boolean;
    get: (id: Id) => V;
    prev: (id?: Id) => Id;
    next: (id?: Id) => Id;
}
export declare class List<V> implements IList<V> {
    constructor(list?: IList<V>);
    has(id: Id): boolean;
    get(id: Id): V;
    prev(id: Id): Id;
    next(id: Id): Id;
    first(): V;
    last(): V;
    forEach(fn: (value: V, id?: Id) => void): void;
    reduce<W>(fn: (memo: W, value: V, id?: Id) => W, memo?: W): W;
    toArray(): V[];
    findId(fn: (value: V, id?: Id) => boolean): Id;
    find(fn: (value: V, id?: Id) => boolean): V;
    idOf(value: V): Id;
    indexOf(value: V): Id;
    idAt(index: number): Id;
    at(index: number): V;
    every(predicate: (value: V, id?: Id) => boolean): boolean;
    some(predicate: (value: V, id?: Id) => boolean): boolean;
    contains(value: V): boolean;
    reverse(): List<V>;
    map<W>(mapFn: (value: V, id?: Id) => W): List<W>;
    filter(filterFn: (value: V, id?: Id) => boolean): List<V>;
    flatten(): IList<any>;
    flatMap<W>(flatMapFn: (value: V, id?: Id) => IList<W>): List<W>;
    cache(): List<V>;
    static isList(obj: any): boolean;
    static create<V>(list: IList<V>): List<V>;
    static has(list: IList<any>, id: Id, depth?: number): boolean;
    static get(list: IList<any>, id: Id, depth?: number): any;
    static next(list: IList<any>, id: Id, depth?: number): Id;
    static first<V>(list: IList<V>): V;
    static last<V>(list: IList<V>): V;
    static forEach<V>(list: IList<V>, fn: (value: V, id?: Id) => void): void;
    static reduce<V, W>(list: IList<V>, fn: (memo: W, value: V, id?: Id) => W, memo?: W): W;
    static toArray<V>(list: IList<V>): V[];
    static findId<V>(list: IList<V>, fn: (value: V, id?: Id) => boolean): Id;
    static find<V>(list: IList<V>, fn: (value: V, id?: Id) => boolean): V;
    static idOf<V>(list: IList<V>, value: V): Id;
    static indexOf<V>(list: IList<V>, value: V): number;
    static idAt<V>(list: IList<V>, index: number): Id;
    static at<V>(list: IList<V>, index: number): V;
    static every<V>(list: IList<V>, predicate: (value: V, id?: Id) => boolean): boolean;
    static some<V>(list: IList<V>, predicate: (value: V, id?: Id) => boolean): boolean;
    static contains<V>(list: IList<V>, value: V): boolean;
    static reverse<V>(list: IList<V>): IList<V>;
    static map<V, W>(list: IList<V>, mapFn: (value: V, id?: Id) => W): IList<W>;
    static filter<V>(list: IList<V>, filterFn: (value: V, id?: Id) => boolean): IList<V>;
    static flatten<V>(list: IList<any>): IList<any>;
    static flatMap<V, W>(list: IList<V>, flatMapFn: (value: V, id?: Id) => IList<W>): IList<W>;
    static cache<V>(list: IList<V>): IList<V>;
}
export default List;
